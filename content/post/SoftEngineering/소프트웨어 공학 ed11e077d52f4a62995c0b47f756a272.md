---
title: "Software Engineering"
date: 2022-10-19T02:28:07+09:00
categories:
- 소프트웨어 공학
- subcategory
tags:
- Software Engineering
keywords:
- 소프트웨어
- 공학
---

# 소프트웨어 공학

[스크랩 요약 정리](https://www.notion.so/21dd2a8e37ab482881c1509176db4687)

## Ch1. 소트웨어 공학 개요

---

소프트웨어는 무엇인가? 

→ 프로그램과 관련된 모든 사항들을 포함, 전문적으로 개발된 소프트웨어는 많은 요소들로 구성

이러한 소프트웨어 제품은 두가지 유형으로 나뉘게 된다

- 일반(generic) 제품 : **특정 개발 조직이 생산한 독립형 시스템**으로서 **개발하는 조직**이 소프트웨어 명세를 관리하게 된다.
- 맞춤식 (custimized, bespoke) 소프트웨어: **특정 고객의 요구에 맞추어 개발하는 시스템**으로서 **구매하는 조직**이 소프트웨어 명세를 관리하게 된다.

위의 차이는 점차 모호해지는 중.

**좋은 소프트웨어의 필수적인 특성**

- 수용성                         → 설계한 목적에 부합하는가?  사용자 유형이 수용할 수 있는가?
- 확실성과 보안성     → 시스템 장애와 외부공격으로부터 안전해야함
- 효율성                         → 시스템 자원을 낭비하면 안됨
- 유지보수성                → 고객의 변화하는 요구를 충족해야함

소프트웨어는 알겠고, 뒤에 공학은 왜 있는 것인가? 

→ 소프트웨어 생산의 모든 관점(기술적 프로세스 외의 다른 사항들도 포함)을 다루는 공학적 학문 분야(주어진 일정과 예산 내에서 필요한 품질의 결과물을 얻는것)

소프트웨어 공학이 왜 중요한가?

- 소프트웨어 시스템에 점점 더 많이 의존하는 상황
- 소프트웨어를 사용하다가 변경하는 경우 비용이 매우 큼 → 따라서 장기적으로 보고 최적의 소프트웨어 시스템을 개발하는 방법이 더 적은 비용을 소요하게 된다.

---

### 소프트웨어 프로세스

→ 소프트웨어 공학에서 사용하는 체계적 접근법(일련의 활동)

총 네 가지 기본 프로세스 활동이 있다.

1. 소프트웨어 명세화  →소프트웨어 동작 시 제약사항 정의 (고객과 엔지니어 사이의 간극 좁히기)
2. 소프트웨어 개발       → 소프트웨어 설계하고 프로그래밍
3. 소프트웨어 검증       → 개발한 소프트웨어가 고객의 니즈를 만족하는지 검증
4. 소프트웨어 진화       → 변화하는 니즈를 반영하고 소프트웨어를 수정 및 개선

소프트웨어에 영향을 미치는 네 가지 문제

1. 이질성
2. 비즈니스와 사회적 변화
3. 보안과 신뢰
4. 규모 

소프트웨어 공학의 기본사항 

1. 시스템은 관리 가능하고 이해 가능한 개발 프로세스를 따라야 함
2. 신뢰성과 성능은 모든 유형의 시스템에 중요
3. 소프트웨어 사양과 요구사항을 이해하고 관리하는 것이 중요
4. 기존의 활용 가능한 자원은 최대한 재사용

→ 일반적으로는 개발에 사용하는 프로그램 언어에 독립적임

소프트웨어 엔지니어는 다음의 행동 기준을 지켜야 한다.

- 비밀 유지 — 고용주나 고객의 비밀은 유지해야한다.
- 능력 — 엔지니어는 자기의 능력 수준을 왜곡해서는 안된다. 능력 밖 일은 맡아서는 안됨
- 지적 재산권 — 특허나 저작권과 같은 지적 재산 사용을 관장하는 법규를 알고, 고용주와 고객의 지적 재산이 확실하게 보호 받을 수 있도록 주의해야 한다.
- 컴퓨터 남용 — 말그대로 컴퓨터를 자신의 개인주의로 인해 자신의 기술적 능력 사용은 안됨.

윤리적 책임 VS 직업적 책임 ?

시스템에 따라서 소프트웨어 공학 실무가 달라지게 됨. 

사례는 4자기 

- 임베디드 시스템(인슐린 펌프 제어 시스템) 물리적인 크기, 반응성과 전력 관리가 전형적인 제약
- 정보 시스템(의무 기록 시스템) 보안, 사용성, 개인정보와 데이터 무결성 유지
- 센서 기반 데이터 수집 시스템 (황무지의 기상 관측기) 까다로운 환경에서도 보장될 정도의 신뢰성과 유지수성
- 지원 환경(디지털 학습 환경) 특정 활동을 지원하기 위한 소프트웨어 도구들을 통합한 시스템

## Ch2. 소프트웨어 프로세스

---

보편적이고, 일반적인 프로세스는 존재하지 않는다. 대부분의 소프트웨어 회사는 그 회사에 맞는 개발 프로세스를 만들게 되고, 개발자의 역량과 개발하는 시스템의 특성을 이용하도록 진화되었다.

계획 또한 프로세스에 포함 된다.

- 계획 주도 프로세스: 모든 프로세스를 활동을 미리 계획하고, 계획에 따라 진행 평가
- 애자일 프로세스: 개발과정에서 점증적이고 연속적으로 계획이 이루어짐

소프트웨어 프로세스 모델

→ 소프트웨어 프로세스를 단순하게 나타낸 것. 

![스크린샷 2022-10-20 오후 4.26.38.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.26.38.png)

일반적인 소프트웨어 프로세스 모델은 세가지가 있다.

1. 폭포수 모델
기본적인 프로세스 활동. **명세화, 개발, 검증과 진화**를 가짐
개별적인 프로세스 단계로 프로세스 모델을 나타냄
2. 점증적 개발
**명세화, 개발 및 검증 활동이 서로 중첩**되는 접근법
연속적인 버전을 통해 시스템을 개발 
3. 통합 및 환경 설정
**재사용 가능한 컴포넌트나 시스템의 사용가능 여부**에 의존하는 접근법
사용할 컴포넌트들을 조합하고 하나의 시스템으로 통합하는데 중점

### 1. 폭포수 모델

말 그대로 폭포수 처럼 흘러내려가는 것을 형상화 했다. 대규모 군사 시스템 개발에 사용했던 공학 프로세스 모델 기반. 계획 주도 프로세스의 한 종류(소프트웨어 개발 시작 전에 모든 프로세스 활동과 일정 계획이 필요). 각 단계는 기본적인 소프트웨어 개발 활동을 직접적으로 반영. 단계는 아래와 같다.

1. 요구사항 분석 및 정의
고객과의 면담을 통해 목표를 구체화 한 후 시스템 명세서로 사용
2. 시스템/소프트웨어 설계
전체 시스템 아키텍처 작성
3. 구현 및 단위 테스팅
설계 구현, 단위 테스팅 수행
4. 통합과 시스템 테스팅
프로그램을 하나로 통합한 후, 시스템 검사, 소프트웨어 시스템 고객에게 전달
5. 운영과 유지보수
가장 생명이 긴 단계로서 시스템 서비스 향상을 위해 전 단계의 오류를 수정하게 된다. 새로운 요구사항을 구성하기 위해 전 단계로 올라가기도 한다.

폭포수 모델의 단점

1. 소프트웨어 프로세스는 단순한 선형 모델일 수 없음
요구사항의 개발적 한계 혹은 코딩 과정의 설계 문제 발견등으로 인해 흐름대로 따라가기가 힘듦
2. 이전 설계가 끝나기 전에는 다음 단계를 시작하지 않음
시스템 변경이 필요할 경우 이전 단계의 수정이 필요 → 많은 비용이 발생할 가능성 多
3. 요구사항을 급히 확정 지을시, 효율이 안 좋은 구조를 가진 시스템을 개발할 가능성이 있음
흐름에서 빵꾸가 생길시 요구사항이 지켜지지 않는 문제 발생

하지만, 임베디드 시스템 하드웨어, 안정성과 보안 분석이 필요한 중대한 시스템, 대규모 소프트웨어 시스템의 서브시스템 등이 폭포수 모델에 적합한 시스템 유형임.

### 2. 점증적 개발

제일 일반적이고, 시스템과 소프트웨어 제품을 개발하는데 가장 많이 사용됨. → 여러 버전을 거쳐 소프트웨어를 진화시킴으로써 최종 시스템 개발 (최최최종…) 변경 사항에 대해 적은 비용으로 쉽게 대처가 가능.

점증적 개발의 장점

- 요구사항 변경을 구현하는 비용이 줄어듦
- 이미 진행된 개발 작업에 대해서 고객의 피드백을 받기가 더 쉬움
여러 단계의 버전을 통해 소프트웨어 시연과 그에 대한 피드백을 줄 수 있고, 구현 정도 확인 가능
- 고객에게 유용한 소프트웨어를 빠르게 전달하고 배포하는 것이 가능
전체 기능이 아니더라도 핵심,필수 기능을 구현하여 고객이 가치를 경험하고 실제로 사용가능.

점증적 개발의 문제점

- 프로세스가 가시적이지 못함
정기적으로 중간 산출물이 필요(진척도 확인을 위한)
- 새로운 증가분이 반영되면서 시스템 구조를 훼손시키는 경향이 있음
새로운 기능이 전에 개발한 기능을 침해하거나 구조의 변화가 필요로 할 경우 많은 비용 발생과 정기적인 리팩토링(소프트웨어를 개선하고 재구성하는 작업)이 필요하게 됨.

### 3. 통합과 환경설정(재사용 지향 소프트웨어 공학)

기존의 소프트웨어를 재사용하는 데 초점을 맞춘 개발 프로세스. 통합 프레임워크를 통해 재사용 가능한 소프트웨어 간의 조합

**재사용 지향 소프트웨어 공학의 각 단계**

1. 요구사항 명세화
2. 소프트웨어 발견 및 평가
필요한 기능을 제공하는 컴포넌트 및 시스템을 발견하고, 평가
3. 요구사항 정제
2번에서 발견한 컴포넌트를 반영하여 요구사항을 수정하고 1번 명세도 다시 정의
4. 애플리케이션 시스템 설정
위에 1-2-3의 일련의 과정을 거친 후 애플리케이션 시스템 설정
5. 컴포넌트 수정과 통합
개별적으로 재사용 가능한 컴포넌트를 수정하여 새로운 컴포넌트를 개발하고 시스템 개발에 통합.

재사용 지향 소프트웨어 공학의 장단점

**장점**

- 비용과 위험 감소
재사용이기 때문에 실질적으로 개발해야하는 부분은 다른 프로세스 모델에 비해 줄일 수 있음
- 소프트웨어를 고객에게 더 빨리 전달할 수 있음
점증적 개발과 마찬가지

**단점**

- 사용자의 진정한 요구사항 만족은 어려움
3단계에서 요구사항을 수정해야 하기 때문에 타협을 해야함
- 소프트웨어 진화에 대한 주도권 상실
컴포넌트에 종속적이기 때문에 개발 조직이 진화에 대한 통제권을 가질 수 없음.

소프트웨어 개발 도구

IDE(integrated Development Environment)

## 소프트웨어 프로세스 활동의 세부사항

명세화/ 설계 및 구현 /  검증 / 진화

위의 네 가지 프로세스 활동은 개발 프로세스의 종류에 따라 다른 방식으로 구성된다.

### 1. 소프트웨어 명세화(=요구공학)

어떤 서비스가 필요한가? 이해하고 정의하고, 시스템의 운영과 개발에 대한 제약사항을 찾아내는 과정. 소프트웨어 프로세스에서 설계와 구현 단계로 이어지기 전에 명세가 확실하게 이루어지지 않을 경우 문제가 발생하게 된다.

한 마디로 고객의 니즈와 개발자의 한계를 견주어보면서 서로의 타협점을 찾는 단계

![스크린샷 2022-10-20 오후 7.06.29.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.06.29.png)

명세화 단계의 세 가지 주요 활동

1. 요구사항 도출 및 분석 (???:요구사항이 뭐세요? 아 그거요? 좀 힘든데 ㅎㅎ)
2. 요구사항 명세화 (???:그래서 요구사항이 ~~라는 거죠? 이대로 진행할게요)
3. 요구사항 검증 (???: 아 생각해보니까 ~~요구사항은 현실성이 떨어지는데요?)

### 2. 소프트웨어 설계 및 구현

고객의 니즈를 맞춘 소프트웨어 시스템을 실질적으로 개발하는 단계. 구현해야 하는 소프트웨어 구조, 시스템이 사용하는 데이터 모델과 구조, 시스템 컴포넌트들 사이의 인터페이스와 알고리즘(경우마다 다름)을 기술한 것.

![스크린샷 2022-10-20 오후 7.10.26.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.10.26.png)

위의 정보는 정보 시스템을 설계하기 위한 단계이다.

설계 활동의 정보는 ‘어떤 소프트웨어를 만들것인가?’에 따라 결정되게 된다.

1. 아키텍처 설계: 시스템의 전체적 구조, 주요 컴포넌트와 그 관계, 구성요소들의 분산 방식
2. 데이터베이스 설계: 구조 및 데이터베이스를 어떻게 표현할지를 결정, 재사용 여부에 갈림
3. 인터페이스 설계: 시스템 컴포넌트들 사이의 인터페이스를 정의
4. 컴포넌트 선택 및 설계: 재사용할 컴포넌트 확인 및 없을 경우 새로운 컴포넌트 설계

위 설계 활동을 거치면 상세 설계 문서를 만들게 되고,  문서는 시스템을 명확하고 정확히 기술하게 된다.

구현 단계에서는 테스팅과 디버깅과정을 수행하게 된다. 일반적인 프로세스는 없지만 무조건, ‘그래서 이게 잘돌아가나요?’를 만족해야한다. 위의 테스팅 결과를 통해 고객의 니즈가 충분히 반영되었는지 검증하게 된다.

컴포넌트 테스팅 → 시스템 테스팅 → 고객 테스팅 단계로 수행된다. 

1. 컴포넌트 테스팅 : 개별적인 컴포넌트가 수행되는가?
2. 시스템 테스팅: 컴포넌트 간의 상호작용 및 문제등이 없는가?
3. 고객 테스팅: 실질적인 사용자가 직접 테스팅 해봤을때 오류가 있는가? 명세에 없는 부분이 있는가? 

최종적인 계획 주도 소프트웨어 프로세스에서의 테스팅 단계

![스크린샷 2022-10-20 오후 7.19.59.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.19.59.png)

소프트웨어 진화

시스템을 발전시키기 위해 하드웨어를 발전시키는 것보다 소프트웨어를 발전시키는 것이 비용적인 면에서 더욱더 효율적이다.  (ex 하드 용량이 부족해! →하드디스크 하나 더 사자! VS 데이터베이스를 좀 더 다듬고 자료구조를 다듬자!) → 후자 승!

![스크린샷 2022-10-20 오후 7.30.00.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.30.00.png)

개발과 유지보수는 연속적인 활동으로 보는 것이 더 옳음.

변경 처리

모든 대규모 소프트웨어 프로젝트에서 변경은 피할 수 없음. 컴퓨터업계에서는 기술의 발전이 지속적으로 계속 이루어지기 때문에 새로운 기술의 도입으로 변화하거나, 외압이나 경쟁에 의한 사업적 대응과 경영 우선순위의 변화 등으로도 변경될 수 있다. 이러한 변경 작업은 소프트웨어 개발 비용을 증가시킴. 

변경 예측(프로토타입 시스템 개발) 및 허용(점증적 개발)등을 통해 재작업 비용을 줄일 수 있다.

### 프로토타이핑

프로토타입이란? 제품의 아이디어를 시연하고 디자인 선택 사항들을 시도해보는 소프트웨어 시스템의 초기 버전. 

**프로토타이핑의 장점**

1. 시스템 사용성 향상
2. 사용자의 실제 요구 사항에 더 맞출 수 있음
3. 디자인 품질 향상
4. 유지 보수성 향상
5. 개발에 드는 노력 감소

### 점증적 인도

점증적 인도란? 소프트웨어 시스템을 여러 개의 증가분으로 나누어 순차적으로 전달. 서비스 우선순위에 따라 증가분에 할당할 서비스 결정 → 우선순위가 높은 서비스를 제일 먼저 구현하고 전달.
증가분 개발이 시작되면 해당 증가분의 요구사항 변경 불가

**점증적 인도의 장점**

1. 시스템 증가분에 대한 요구사항에 대한 힌트를 얻기 쉬움
2. 고객이 전체 시스템이 전달될 때까지 기다릴 필요가 없음
3. 시스템에 반영할 변경 사항을 비교적 쉽게 통합할 수 있음
4. 가장 중요한 시스템 서비스를 가장 많이 테스트하게 됨

**점증적 인도의 단점**

1. 기존 시스템을 신규 시스템으로 대체하려는 경우 문제 발생 →기존 시스템의 모든 기능이 필요. 새로운 시스템을 사용하지 않으려는 보수적인 경향이 있음.
2. 여러 기본 기능을 필요로 하는 시스템의 경우 맞지 않음 → 하지만 이러한 시스템이 대부분이다…
3. 여러 기관의 조달 방식에 맞지 않는 방식(큰 조직에서 부적합)

## 프로세스 개선

기존 프로세스를 이해한 후 이 프로세스를 바꾸어서 제품의 품질을 향상시키거나 비용과 개발 시간을 단축시키는 활동을 의미. 크게 두 가지 방법을 사용하게 된다. 

1. 프로세스 성숙도 접근법
* 프로세스와 프로젝트 관리 기법을 개선하는 것과 바람직한 소프트웨어 공학 실무를 조직에 소개하는 것에 중점. 목표 → 제품 품질과 프로세스 예측 가능성 향상
일반적으로  ‘측정 → 분석 → 변경 → 측정 → … ’ 
2. 애자일 접근법
* 반복적 개발과 오버헤드의 감소에 중점. 목표 → 가장 적은 오버헤드를 가지고 고객의 요구 사항 변경에 대한 대응

일반적인 프로세스 개선 작업(프로세스 성숙도 접근법)

1. 프로세스 측정
프로세스나 제품의 여러가지 속성을 측정. 측정한 기준 값이 프로세스 개선 효과의 평가 기준
2. 프로세스 분석
프로세스의 약점과 방해물을 찾음. 프로세스를 설명하는 프로세스 모델 개발
3. 프로세스 변경 
분석을 통해 찾은 약점을 개선하기 위한 프로세스 변경을 제안. 변경 작업 후, 변경 효과성에 대한 데이터를 수집하는 작업을 다시 시작(프로세스 측정 단계)

프로세스 역량 성숙도 모델 수준

1. 초기          → 관리 X
2. 관리            → 제품 관리 절차가 정의되고 사용됨
3. 정의           → 프로세스 관리 절차와 전략이 정의되고 사용됨
4. 정량적 관리        → 품질 관리 전략이 정의되고 사용됨
5. 최적화              → 프로세스 개선 전략이 정의되고 실제로 사용됨.

---

## 애자일 기법

예전엔 계획 주도 접근법이 주로 사용되었으나, 개발팀의 규모가 크고 회사의 규모가 클 수록 소프트웨어 제작 속도가 매우 오래걸리게 되고, 많은 오버헤드가 발생하게 된다. 또한, 개발팀이 소프트웨어에 집중하고, 요구사항이 자주 변경되는 애플리케이션의 개발 수요가 늘어나게 되면서 애자일 기법이 생기게 되었다. ——> 신속한 개발 = 애자일 기법

**애자일 기법**이란?

- 사용하는 증가분이 적은 점증적 개발 기법
- 고객이 개발 프로세스에 참여 → 문서화 최소화
- 설계와 구현을 프로세스 중심 활동으로 간주 → 개발이 먼저다!

폭포수 모델과 애자일 기법의 간략적인 비교!

![스크린샷 2022-10-21 오후 8.18.48.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-21_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.18.48.png)

애자일 기법들의 공통적 특징

- 중첩된 명세화(즉, 상세한 명세화 X)
- 시스템을 증가분의 연속으로 구현
- 개발 프로세스를 지원하기 위해 방대한 도구 사용

애자일 선언

1. 솔플 < 협업
2. 문서 < 소프트웨어
3. 계약 < 협업
4. 계획 < 변화

왼쪽은 폭포수에 가깝다. 

애자일 기법을 적용하기 좋은 예

- 중소 규모의 제품을 판매할 목적 → 작은 규모
- 맞춤형 시스템을 개발 → 수평적인 관계에서 적합
- 관리자, 고객, 개발팀 간의 서로 커뮤니케이션이 자주 이루어짐

구글, 아마존같은 큰 기업들도 개발자들을 잘게 쪼갠 작은 조직으로 구성하여 프로젝트를 진행한다. 조직의 규모가 작기에 신속한 의사결정이 가능하다 

### 익스트림 프로그래밍

위의 잘개쪼개진 조직은 익스트림 프로그래밍을 통해 소프트웨어를 개발하게 된다. 서로 다른 프로그래머가 하루에 여러 신규 시스템 버전을 만들고 통합하고 테스트하는 일련의 과정들을 반복하게 된다.

익스트림 프로그래밍의 특징

1. 작은 크기의 잦은 시스템 릴리즈
2. 고객이 개발팀에 지속적으로 참여
3. 지속가능한 개발 프로세스
4. 변화 허용(리팩토링, 통합, 테스트, 지속적인 릴리스)
5. 단순함 유지

애자일 기법을 채택한 회사 → 조직에 알맞는 익스트림 프로그래밍 기법을 사용

여기서 잠깐! 리팩토링이란?
프로그래밍 팀이 소프트웨어에서 개선 가능한 부분을 찾아서 즉시 구현. 소프트웨어의 구조와 신뢰성을 개선한다. 하지만 개발 마감 시간의 압력으로 인해 신규 기능을 처리하는데 많은 시간이 소요되어 실질적인 적용은 어려움.

리팩토링 기법!

메서드 추출, 임시값을 쿼리로 변경, 필드 캡슐화 하기,메서드의 인라인화, 메서드 옮기기(빈도에 따라), 조건문을 다형성으로 바꾸기(elif 보다는 클래스로!), 

### 사용자 스토리

시스템의 사용자. 즉, 고객이 경험할 수 있는 일종의 사용 시나리오를 만드는 것. 딱딱한 요구사항 명세보다  더욱더 쉽게 시스템을 이해 할 수 있음. 하지만, 스토리를 구상하는데 있어서 요구사항이 누락되는 문제가 발생할 수도 있고, 스토리가 요구사항을 다룰 수 있는지 판단하기도 어려움.

스토리 카드 VS 작업 카드

스토리 카드는 고객의 요구를 담고 있는 스토리를 간단하게 설명하는 도구이고 작업 카드는 스토리 카드의 내용을 여러 단계로 나누고, 각 과업을 구현하는데 드는 노력과 자원을 추정 및 고객과의 의견을 주고 받는 도구로서 사용된다.

### 테스트 우선 철학

점증적 개발 방식. 명세가 없고, 테스팅 프로세스의 단계가 진척을 나타네게 된다. 

테스트 주도 개발 기법

1. 코드를 작성하기 전에 테스트를 먼저 작성
2. 테스트는 프로그램과 같이 작성되어야 함
3. 새로운 기능이 추가 되면 이전 테스트와 새로운 테스트가 자동적으로 수행되어야함. 

고객은 인수 테스트(시스템이 고객의 데이터를 가지고 실질적인 테스트를 하는 과정)를 도와 줘야 하고, 테스트를 작성해야 한다. 따라서 시간이 많이 소요되게 된다. 고객의 스타일이 다르기 때문에 요구사항만 전달하고 끝내고 싶어하는 경우도 있다. 그러면 위 방법은 괴리가 있는 모습.

프로그래머의 입장에서 테스트보다는 프로그래밍에 관심이 있기 때문에 어줍잖은 테스트는 오히려 소프트웨어의 성능을 망치고, 점증적인 테스트가 불가능한 경우도 생긴다. 또한, 테스트 집합이 소프트웨어의 완전한 커버리지를 보장할 수 있는가? 여부 또한, 확인하기가 어렵다.

짝 프로그래밍은 프로그래머 짝이 유동적으로 바뀌면서 개발 프로세스 동안에 모든 팀 구성원이 서로 같이 작업을 해볼 수 있도록 하는것이 짝 프로그래밍이다. 공동책임 개념을 제공하고, 리팩토링과, 비정형적 프로세스 리뷰가 가능하다. 하지만, 두명이서 코딩하는 것이 과연 효율적인가?

학생 짝 → a: 이게 뭐임? b: 나도 모르겠는데? → 서로 공부하고 찾아봄 → 좋은 피드백
시니어 개발자 짝 → a: 아 이거 쓰면 되겠다? b: 아 그거 보다는 이게 낫지 않을까? → 그냥 따로 하자.. 

서로간의 지식 공유가 필요한 경우에 사용됨. 대부분의 애자일 기법을 도입한 회사는 사용하지 않음.

## 스크럼

예를 들면 notion의 사용 → 팀프로젝트에 있어서 작업공간을 의미한다.  

용어 설명

스크럼: 매일 이루어지는 팀의 회의로 진척사항, 처리해야할 업무 우선순위를 매긴다.
스크럼 마스터: 스크럼에 대빵. 외부와 회사의 접점(연결통로)느낌 
스프린트: 개발 달리자!
속도: 한번의 스프린트에서 팀의 제품 백로그(to do list)를 얼마나 감당할 수 있는지에 대한 추정치.

스크럼 스프린트 주기

![스크린샷 2022-10-22 오후 5.02.21.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.02.21.png)

제품 백로그

- 스크럼 스프린트 사이클의 출발점
- 프로젝트에서 완료되어야 하는 작업의 목록을 담고 있음
- 제품 사용자가 우선순위를 정함

항목 선정

- 고객과 일하는 프로젝트 팀 전체가 참여
- 제품 백로그에서 스프린트 동안 개발할 항목들을 선택

스프린트 계획

- 선정한 항목들에 대해서 필요한 시간 예측
- 스프린트 백로그 작성

스프린트

- 각자 역할에 따른 스프린트(개발)시작
- 매일 짧은 미팅인 스크럼을 진행 (진척도 파학, 우선순위, 정보공유, 문제 해결)

이때 사용되는 스크럼 보드가 Jira, Notion등이 사용되게됨.

스크럼의 장점

1. 제품이 이해당사자들과 관련될 수 있는 관리가 가능하고 이해할 수 있는 조각들로 나뉨
2. 불안정한 요구사항에 의한 지연 X
3. 모든 팀이 모든 것을 볼 수 있고, 결과적으로 팀 의사소통과 의욕이 향상됨
4. 고객은 제때 증가분을 받아볼 수 있고, 제품이 동작하는 방식에 대한 피드백 확보
5. 고객과 개발자의 밀접한 신뢰감 → 프로젝트 성공 기대 → 긍정적 문화

세계화 흐름에 맞춰 팀 구성원이 여러 나라에 흩어져 있는 경우? → 분산 스크럼 사용

애자일 기법의 규모

애자일 기법은 작은 규모의 프로그래밍 팀이 사용할 수 있도록 개발되었으나, 큰 규모의 소프트웨어 시스템 혹은 대규모 회사에서도 사용 가능하도록 많은 방법이 생김 크게 2가지 

1. 스케일 업 — 대규모의 시스템을 개발 할 때에 애자일 기법을 적용
2. 스케일 아웃 — 소프트웨어 개발 경험을 가진 큰 조직에 애자일 기법을 적용

**큰 기업에서 애자일 기법의 한계**

애자일 기법은 새로운 소프트웨어를 개발하는데 적합함 → 하지만 큰 규모의 회사는 유지 보수 과정에서 많은 비용이 발생하게 됨. 

큰 기업일수록 신중해야하기에 명세가 꼭 필요함. 하지만 애자일 기법에는 요구사항 문서를 정의하기 힘듦. 

계약 , 소프트웨어 유지 보수등의 많은 부분에서 한계가 있음.

→ 따라서 애자일과 계획 주도 방법을 묶어서 사용!

### 애자일 스케일링 모델(IBM) 및 다중 팀 스크럼

애자일 기법의 대규모 적용을 목적

![스크린샷 2022-10-22 오후 5.18.43.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.18.43.png)

---

# 요구사항

요구사항

- 한 시스템이 제공해야 하는 서비스들과 그 서비스들의 동작에 관한 제약을 기술한 것. 특정 목적을 제공하는 시스템에 대한 고객의 요구 반영

요구공학

- 서비스와 제약사항들을 찾고, 분석하고, 문서화하며 점검하는 프로세스

요구사항은 크게 2가지로 나뉘게됨

1. 사용자 요구사항 — 시스템이 제공해야하는 서비스에 대한 고수준의 서술 or 제약사항
2. 시스템 요구사항 — 시스템 기능에 대한 상세하고 정형화된 정의

ex) mentcare 시스템 

![스크린샷 2022-10-22 오후 8.27.40.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.27.40.png)

이해당사자는 시스템 서비스 사용에 있어서 관련이 있고, 영향을 받는 사람이 모두 해당하게 된다.

### 타당성 조사(Feasibility studies)

요구공학 프로세스 초기에 이루어져야 하는 짧은 기간의 집중적 조사

- 시스템이 조직의 전체적 목적에 기여하는가?
- 시스템이 현재의 기술을 이용해서 주어진 일정과 예산으로 구현이 가능한가?
- 시스템을 사용하는 다른 시스템과 통합을 할 수 있는가?

→ 만일 하나라도 ‘No’가 나올경우 프로젝트 진행은 보류!

‘요구공학 = 요구사항 문서 = 시스템 개발 계약’이라고 볼 정도로 중요한 부분을 차지한다.

기능적 요구사항

- 시스템이 제공해야하는 서비스와 그 외 다른 구체적은 동작 방식, 반응 방식
- 어떠한 경우에는 시스템이 해서는 안 되는 것들을 명시적으로 기술하기도 함

비기능적 요구사항

- 시스템이 제공하는 서비스나 기능에 대한 제약 사항
- 시간적 제약, 개발 프로세스에 대한 제약과 표준에 의해 지켜야 하는 제약
- 개별적인 시스템 특징이나 서비스보다는 전체 시스템에 적용되는 경우가 많음

## 요구사항 검증

요구사항을 검증하는 것은 고객이 정말 원하는 시스템을 정의하고 있는지를 점검하는 과정이다. 시작이 반이라는 말처럼, 요구사항이 완벽해야 이후 단계에서 원할한 작업이 가능하다. 만일 요구사항 문서의 결함이 발견될경우 막대한 재작업 비용이 필요하다. 

요구사항 검증시 점검해야 하는 사항들

1. 유효성 점검 → 이 요구사항이 니 요구사항이냐!
2. 일관성 점검 → 
3. 완전성 점검 → 쟤가 말씀드린 요구사항은 다 포함된거죠?
4. 실현성 점검 → ???: 아.. 이 기능은 안될것같은데요..?? X
5. 검증가능성 → 요구사항을 문서로 작성해서 검증이 가능해야 함.

요구사항 검증 기법

1. 요구사항 검토 → 검토팀이 요구사항의 오류와 불일치사항을 체계적으로 분석
2. 프로토타이핑 → 실행가능한 시스템 모델을 개발 → 사용자와 고객들이 사용 → 피드백
3. 테스트 케이스 생성 → 요구사항에 대한 테스트를 검증 프로세스의 일부로 만드는 기법

## 요구사항 프로세스

1. 도출 및 분석 — 이해당사자들과의 상호 작용을 통해 요구사항을 발견하는 것
2. 명세화 — 요구사항을 표현 형태로 바꾸는 것
3. 검증 — 요구사항이 실제로 고객이 원하는 시스템을 정의하고 있는지를 점검하는 것 

위 과정이 나선형처럼 계속 반복되게 되나 반복횟수 혹은 진행방식은 환경에 따라 달라짐. 초기에는 고수준의 비즈니스, 기능적/비기능적 요구사항을 포함하고, 후반에는 상세한 시스템 요구사항에 집중

### 요구사항 도출

이해당사자들이 하는 업무와 그들이 업무 지원을 위해 신규 시스템을 활용하는 방식을 이해하는 것. 소프트웨어 엔지니어는 요구사항을 도출하기 위해 이해당사자들과 함께 일하게 됨. → 쉽지 않음

요구사항 도출이 쉽지 않은 이유

- 이해당사자들의 애매하고 비현실적인 요구사항
- 도메인 경험이 전제된 상태에서의 요구사항

— 위 의 두 이유의 공통점은 ‘역지사지’. 엔지니어들은 이해당사자들의 업무를 이해하는데 있어 어려움이 있고, 마찬가지로 이해당사자들은 엔지니어들의 업무를 이해하지 못하는 간극으로 인해 발생 —

- 여러 명의 이해당사자들의 서로 다른 요구사항들
같은 요구사항이여도 이해당사자들간의 표현 방식이 서로 다를 수 있기에 엔지니어는 요구사항에 대한 모든 잠재적 출처를 갖고 공통점과 상충점을 찾아내야 함.
- 정치적 요소가 시스템의 요구사항에 영향을 줄 수 있음
관리자 계정의 ‘힘’을 위해 특정 시스템 요구사항을 요청할 수 있음
- 유동적인 경제, 비즈니스 환경
유동적이기 때문에 환경, 요구사항의 중요성, 신규 요구사항 등 많은 변수가 작용됨.

아래와 같은 방식으로 요구사항을 도출하고 분석하게 됨.

![스크린샷 2022-10-22 오후 8.49.15.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.49.15.png)

1. 요구사항 발견 및 이해
이해당사자들 간의 상호 작용 프로세스, 도메인 요구사항과 문서를 확보하게 됨
2. 요구사항 분류 및 구성
요구사항들을 모으고 조직화해서 일관성 있는 그룹으로 분류
3. 요구사항 우선순위 정하기 및 협상
요구사항의 우선순위를 정하고, 서로 충돌하는 요구사항을 찾고 협상
4. 요구사항 문서화
다음 단계에서 사용할 수 있도록 요구사항을 문서화

요구사항을 도출할 때 중요한 사항

- 이해당사자들의 정보를 조직화하고 그룹화 → 요구사항을 분석 정리하는데 도움이 됨
- 이해당사자들과 정기적으로 미팅을 가지는 것 → 절충안제안!
- 문서화 단계에서 쉬운 언어와 다이어그램을 사용 → 이해당사자들이 이해하고, 추가 의견

### 요구사항 도출 기법

요구사항 도출을 위해서 다양한 유형의 이해당사자와 미팅을 가지게 됨.

1. 인터뷰
2. 관찰 또는 문화기술적 연구 — 일하는 사람들의 모습을 지켜보고 무엇을 어떻게 사용하는지 관찰
3. 스토리와 시나리오

**인터뷰**

인터뷰를 통해 이해당사자들이 현재 사용하고 있는 시스템과 개발해야 하는 시스템에 대한 질문을 하게 됨. 두 가지 유형으로 나뉘게 됨. 

1. 폐쇄적 인터뷰 — 미리 정의된 질문들에 답하기
2.  개방적 인터뷰 — 정의된 내용이 없이 다양한 질문을 통해 여러가지 문제를 탐색하고 이해할 수 있음

위에 두 유형을 혼용하여 사용하는것이 일반적이다. 인터뷰에도 어려움이 존재한다.

- 도메인 지식을 추출하기 어려움 — 요구사항 도출의 어려운점 1,2와 결이 비슷함.
- 조직적 요구사항과 제약에 대한 지식을 도출하기 어려움 — 기업의 내부사항을 다른 사람에게 알리는 것이 쉽지않음. → 사내 정치 문제

엔지니어의 입장에서 이해당사들의 말을 귀담아 듣고, 인터뷰를 받는 사람이 논의를 시작할 수 있도록 유도해야 함.

**문화기술적 연구**

정형적 프로세보다 잘 드러나지 않는 시스템 요구사항을 발견하는데 좋음. 인터뷰를 통해 자기의 업무를 명확하게 설명하는 것은 쉽지않음(자연스럽고, 몸에 익은 루틴이기 때문)

따라서 관찰을 통해 이해당사자들이 실제 일하는 방식으로부터 요구사항을 얻을 수 있고, 이해당사자들간의 활동을 통해 협업에 관한 부분을 볼 수 도있음.

![스크린샷 2022-10-22 오후 9.07.23.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.07.23.png)

문화기술적 연구의 특징

- 프로토타입 개발과 결합될 수 있음.
— 프로토타입 개선 주기를 줄일 수 있고, 프로토타이핑을 위 연구에 초점을 맞출수도 있음

## 요구사항 명세

사용자 요구사항 및 시스템 요구사항을 요구사항 문서로 작성하는 과정!

이상적인 요구사항 문서는 대상이 사용자, 시스템 요구사항을 모두 포함하고, 명확하고, 모호하지 않으며, 이해하기 쉽고, 완전하고, 일관성이 있어야 함 → 어려움 →  충돌이나 불일치가 자주 발견되기 때문

사용자 요구사항

- 단순한 표, 약식, 그리고 직관적인 다이어그램을 가지고 자연어로 작성
- 기술적 지식이 없는 시스템 사용자가 이해가능하도록 기능적/비기능적 요구사항을 포함해야 함
- 시스템의 외부 동작에 대해서만 명세 — 상세한 설명은 X

시스템 요구사항

- 사용자 요구사항의 확장 버전
- 소프트웨어 엔지니어가 시스템 설계의 출발점으로 사용 — 상세한 설명 O
- 완전해야 하며, 전체 시스템에 대한 상세한 명세로 이루어져야 함
- 시스템의 외부 동작과 운영상의 제약에 대해서만 기술 — 시스템의 how to는 X

**자연어 명세**

명세에서 가장 많이 사용되는 수단

가이드라인!

1. 표준 형식을 만들어 적용할 것 — 문장의 길이
2. 언어를 일관성 있게 사용할 것 — should와 shall의 차이를 구분해서 사용
3. 텍스트 강조를 사용
4. 요구사항을 읽는 사람이 기술적, 소프트웨어 공학적 언어를 이해할것이라고 생각하지 말 것
5. 가능하면 각각의 사용자 요구사항에 대한 근거를 남길 것 — 추후 요구사항 변경에 있어서 사용

ex. 

![스크린샷 2022-10-22 오후 9.23.51.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.23.51.png)

**구조적 명세**

자연어의 장점과 통일성이 좋음. 템플릿을 사용해서 시스템 요구사항을 명세

포함해야 하는 정보

1. 명세를 하는 기능이나 개체에 대한 설명
2. 입력과 입력의 출처에 대한 설명
3. 출력과 출력의 목적지에 대한 설명
4. 계산에 필요한 정보나 시스템에서 필요한 다른 개체들에 대한 정보
5. 수행해야 하는 동작에 대한 설명
6. 사전조건 및 사후조건
7. 동작으로 인한 부작용에 대한 설명

ex)

![스크린샷 2022-10-22 오후 9.24.16.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.24.16.png)

**유스케이스** (UML의 기본 요소)

그래픽 모델과 구조적인 글을 이용하여 사용자와 시스템 사이의 상호 작용을 설명하기 위한 방법

ex)

![스크린샷 2022-10-22 오후 9.25.57.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.25.57.png)

요구공학 보다는 시스템 설계에서 더 유용함

### 요구사항 문서

소프트웨어 요구사항 문서 VS 애자일 기법에서의 요구사항 문서

**소프트웨어 요구사항 문서**

- 시스템 개발자가 구현해야 하는 것에 대한 공식적인 내용
- 시스템에 대한 사용자 요구사항과 시스템 요구사항에 대한 상세 명세를 포함
- 요구사항 문서가 반드시 필요한 경우 (외주, 여러 팀의 부분 개발, 요구사항 상세분석)
- 요구사항 문서가 필요 없는 경우도 있음

**애자일 기법에서의 요구사항 문서**

- 공식적인 문서를 사용하지 않음
- 사용자 요구사항을 점진적으로 수집해서 카드에 작성하거나 짧은 사용자 스토리로 칠판에 기록하는 방식을 많이 이용
- 요구사항이 불안정한 비즈니스 시스템에 대해서는 적당한 접근법

이러한 요구사항 문서는 사용자에 따라 요구사항 문서가 다르다.

- 고객 → 요구사항을 설명
- 개발자와 테스터 → 정확하고 상세한 수준의 요구사항을 정의, 향후 진화에 대한 정보 포함
- 시스템 설계자 및 유지보수 엔지니어 → 예상되는 변경에 대한 정보, 제한적인 설계 결정을 피하고, 신규 요구사항에 따라 시스템을 바꾸는 작업을 하는 데 도움을 줌

## 요구사항 변경

사용하다보면 미처 예상하지 못한 불편함이나 ‘이러한 기능이 있으면 좋을 것 같은데…’라는 생각을 하기 마련이다. 비즈니스 환경의 변화 때문에 시스템 요구사항에 대한 변경이 주로 발생한다.

따라서 이러한 요구사항은 관리를 해야 한다. → 애자일 개발 프로세스

요구사항 관리 계획 (어떻게 개선되어가는 요구사항을 관리 할 것인가?)

1. 요구사항 식별: 각 요구사항을 유일하게 판별
2. 변경 관리 프로세스: 변경에 대한 영향과 비용을 평가하는 활동들
3. 추적가능성 정책: 기록해야 하는 관계를 정의하고, 기록들을 유지보수하는 방법
4. 도구 지원: 요구사항에 대한 엄청난 양의 정보를 처리해야 하기 때문에 다양한 도구들을 사용할 수 있음.
요구사항 보관, 변경 관리, 추적가능성 관리를 위해 도구 지원이 필요하다.

변경 관리 프로세스의 세 가지 주요 단계

1. 문제 분석 및 변경 명세
2. 변경 분석 및 비용 산출
3. 변경 구현

---

위의 요구사항을 다 정리 했으면 → 동작시킬 시스템을 만들어야지?

## 시스템 모델링

시스템의 추상 모델을 개발하는 프로세스이다. 주로 그림을 통해 나타낸다. 기존 및 새 시스템의 모델 모두 요구공학 중에 사용된다. 기존 시스템의 모델의 경우 기존 시스템이 무엇을 하는지 밝혀 주고 이해당사자 간 논의를 강점과 약점에 집중하는데 사용한다. 새시틈의 모델의 경우 제안된 요구사항들을 다른 시스템 이해당사자들에게 설명하는데 사용된다.

시스템 모델(검토 중인 시스템의 추상화) 

여러 관점에서 시스템을 표현하기 위해 여러 모델들을 개발 가능

- 외부 관점 — 시스템의 컨텍스트나 환경을 모델링
- 상호 작용 관점 — 시스템과 그 환경 사이의 상호 작용을 모델링
- 구조 관점 — 시스템의 구성이나 시스템에 의해 처리되는 데이터의 구조를 모델링
- 동작 관점 — 시스템의 동적인 행동을 모델링

### UML(Unified Modeling Language)

객체지향 모델링의 표준 언어. 13개의 다이어그램 유형이 있음. 

- 액티비티 다이어그램 — 프로세스나 데이터 처리와 관련된 액티비티
- 유스케이스 다이어그램 — 시스템과 그 환경 간의 상호 작용
- 시퀀스 다이어그램 —액터와 시스템 간, 시스템 컴포넌트들 간의 상호 작용
- 클래스 다이어그램 — 시스템의 객체 클래스들과 클래스들 간의 연관을 보여줌
- 상태 다이어그램 — 시스템이 내부 또는 외부 이벤트에 대해 어떻게 반응하는지 보여줌

## 컨텍스트 모델

시스템 경계는 개발을 시작하기 전 어떤 것이 시스템에 포함되는지 여부를 결정 따라서, 시스템 명세의 초기 단계에서 정한다. 이러한 시스템 경계에 대한 결정을 내리면, 단순한 아키텍처 모델을 생성하고, 컨텍스트와 시스템이 환경에 가지는 의존성에 대해 정의하게 된다.

시스템과 외부 시스템의 관계의 관계는 반드시 고려되어야 함. 간단한 모델은 비즈니스 프로세스 모델 같은 다른 모델들과 같이 사용된다.

UML 액티비티 다이어그램

- 프로세스들의 액티비티들과 한 액티비티에서 다른 액티비티로 제어의 흐름을 보여줌
    
    ![스크린샷 2022-10-22 오후 10.55.29.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.55.29.png)
    

### 상호 작용 모델

무엇과 상호 작용을 하냐? 3가지가 존재한다. 사용자, 시스템간, 컴포넌트

1. 사용자 상호 작용 모델링: 사용자 요구사항을 확인하는 데 도움을 줌
2. 시스템간 상호 작용 모델링: 일어날 수 있는 시스템 간 통신 문제를 밝혀줌
3. 컴포넌트 상호 작용 모델링: 제안된 시스템 구조가 요구되는 수준의 시스템 성능과 확실성이 제공되는지 이헤되는데 도움을 줌.

상호 작용 모델링에 두 가지 접근법

- 유스케이스 모델링: 시스템과 외부 에이전트와의 상호 작용을 모델링
- 시퀀스 다이어그램: 시스템 컴포넌트들 간의 상호 작용을 모델링

위 두 가지를 같이 사용이 가능하다.

유스케이스는 위에서 잠깐 살펴보았음

**시퀀스 다이어그램**

- 액터와 시스템의 객체들간의 상호 작용과 객체들 간의 상호 작용을 모델링하기 위해 주로 사용한다. UML은 여러 다른 종류의 상호 작용이 모델링 될 수 있도록 시퀀스 다이어그램을 위한 풍부한 문법을 가지고있다.
- 특정 유스케이스나 유스케이스 인스턴스에서 일어나는 상호 작용의 순서를 보여줌.
    
    ![스크린샷 2022-10-22 오후 11.00.19.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.00.19.png)
    

 

## 구조 모델

- 시스템을 구성하는 컴포넌트들과 그들간의 관계로 시스템 구성을 보임 (정, 동적 모델 모두 가능)
- 시스템 아키텍처를 논의하고 설계할 때 생성
- 아키텍처 설계는 소프트웨어 공학에서 중요한 주제
- 아키텍처 모델을 표현하는 데 UML 컴포넌트, 패키지, 배치 다이어그램 모두가 사용될 수 있음.

**클래스 다이어그램**

프로그래밍언어의 클래스를 생각하면 됨. 시스템의 클래스들과 그들 간의 연관을 보여주는 객체지향 시스템 모델을 개발할 때 사용됨.

![스크린샷 2022-10-22 오후 11.03.06.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.03.06.png)

상새내역이 추가된 일반화 계층구조

![스크린샷 2022-10-22 오후 11.11.49.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.11.49.png)

## 동작 모델

시스템이 실행될 때의 동적 행동에 대한 모델 
— 시스템이 환경의 자극(데이터 도착, 이벤트)에 반응할 때, 무엇이 일어나는지 또는 무엇이 일어나도록 의도되었는지를 보여줌 

시스템별 동작 방식으로 데이터 처리 시스템과 실시간 시스템으로 나뉘게 된다.

**데이터 주도 모델링**

1. 데이터 주도 모델
입력 데이터의 처리와 이와 연관된 출력 생성과 관련된 일련의 행동을 보여줌, 처음으로 사용된 그래픽 소프트웨어 모델
2. 데이터 흐름 모델
특정 프로세스와 관련된 데이터가 어떻게 시스템을 통해 이동하는지 보여줌, 간단하고 직관적이어서 이해당사들이 더 접근하기 쉬움.

ex) 인슐린 펌프 동작의 액티비티 모델

![스크린샷 2022-10-22 오후 11.17.15.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.17.15.png)

**이벤트 주도 모델링**

시스템이 외부와 내부 이벤트에 대해 어떻게 반응하는지를 보여줌 → 시스템이 유한한 수의 상태를 가지고 이벤트가 한 상태에서 다른 상태로 전이를 일으킨다는 가정을 기반으로 함

실시간 시스템을 설계하고 문서화할 때 광범위하게 사용됨

상태 다이어그램을 이용하여 지원함

ex) 마이크로웨이브 오븐의 상태 다이어그램

![스크린샷 2022-10-22 오후 11.31.07.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.31.07.png)

**상태기반 모델링**

큰 모델에서는 어울리지 않음 → 표시해야 할 상태가 너무 많기에 숨길 필요가 있음

ex) 마이크로웨이브 오븐의 동작

![스크린샷 2022-10-22 오후 11.32.22.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.32.22.png)

## 모델 주도 공학(MDE)

프로그램보다 모델이 개발 프로세스의 주요 출력물인 소프트웨어 개발 접근법 모델 주도 아키텍처의 아이디어로부터 개발 되었음.

장점

- 시스템을 보다 더 상위 단계의 추상화 관점에서 다룰 수 있음
- 시스템을 새로운 시스템에 적용하는데 드는 비용이 저렴함

단점

- 모델은 추상화를 위한 것이며, 구현을 위해서 반드시 적합한 것은 아님
- 코드 생성을 통해서 얻은 비용 절감 효과보다 새로운 플랫폼용 변환기를 개발하는데 드는 비용이 더 많을 수 있음.

## 모델 주도 아키텍처

시스템을 기술하기 위하여 UML 모델의 일부를 사용하는 소프트웨어 설계와 구현에 대한 모델 중심 접근법. 세 가지 유형의 추상 시스템 모델을 생성할 것을 권장

- 계산 독립 모델 (CIM)
시스템에서 사용되는 중요한 도메인 추상화를 모델링(도메인 모델링)
- 플랫폼 독립 모델(PIM)
구현을 참조하지 않고 시스템의 동작을 모델링, UML의 정적 시스템 구조와 외부와 내부 이벤트에 어떻게 반응하는지를 보여주는 모델을 이용하여 기술
- 플랫폼 특화 모델(PSM)
각 응용 플랫폼별로 플랫폼 독립 모델을 변환한 것
각 계층에서 플랫폼에 특화된 세부사항을 추가하는 PSM 계층들이 존재할 수 있음

모델 기반 공학

엔지니어들이 구현의 상세함에 신경 쓰지 않고 시스템에 대해 추상화의 상위 수준에서 생각할 수 있게 해 줌 → 오류 가능성을 줄이고, 설계와 구현 프로세스 속도를 올리며, 재사용이 가능하고 플랫폼 독립적인 응용 모델의 생성을 가능케 함

시스템을 새로운 플랫폼 기술에 적용시키 위해 모델 번역기르 만듦

MDA(Model-Driven-Architecture)의 근간이 됨.
→ 모델들 간의 변환이 정의되고 소프트웨어 도구에 의해서 자동으로 적용될 수 있다는 개념

MDA 변환

![스크린샷 2022-10-22 오후 11.42.04.png](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%A8%20ed11e077d52f4a62995c0b47f756a272/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-10-22_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.42.04.png)

- 서로 다른 CIM에서 사용되는 개념들을 연결 → 어려운 문제
- PIM에서 PSM으로의 번역은 간단한 기술적 문제

MDA도입은 쉽지않다..

- MDA는 플랫폼 특화 번역기를 포함한 도구들을 부분적으로 지원(ex. PIM → PSM)
- 지역 환경에서 가용한 설비를 활용할 수 있도록 특별한 목적의 번역기가 생성되어야 할 수 있음. 
→ 회사 자체적으로 도구를 개발하고 유지하는 것을 원치 않음
- 이와 같은 특별한 도구가 없다면 MDA는 추가의 수작업 코딩이 필요함
MDA 접근법의 경제성을 감소시키게 됨.

괜히 MDA기법을 적용 했다가 배보다 배꼽이 더 커지는 상황이 발생할 뿐더러, MDA가 대두되던 시기에 애자일 기법이 광범위하게 채택됨.